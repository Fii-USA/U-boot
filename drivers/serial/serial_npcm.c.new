// SPDX-License-Identifier: GPL-2.0+
/*
 * Copyright (c) 2021 Nuvoton Technology Corp.
 */

#include <common.h>
#include <dm.h>
#include <serial.h>
#include <clk.h>
//#include <asm/arch/uart.h>

/* Register offsets */
#define RBR	0x00	/* Receive Buffer Register */
#define THR	0x00	/* Transmit Holding Register */
#define IER	0x04	/* Interrupt Enable Register */
#define FCR	0x08	/* FIFO Control Register */
#define LCR	0x0C	/* Line Control Register */
#define LSR	0x14	/* Line Status Control Register */

/* Register fields */
#define LCR_WLS_8BITS	3
//#define	FCR_RFITL_4B	(4 << 4)
#define	FCR_TFR		BIT(2)
#define	FCR_RFR		BIT(1)
#define	FCR_FME		BIT(0)
#define	LSR_THRE	BIT(5)
#define	LSR_RFDR	BIT(0)
#define	LCR_DLAB	BIT(7)

struct npcm_serial_plat {
	//struct npcm_uart *reg;
	void __iomem *base;
	u32 uart_clk;
};
#if 0
static int npcm_serial_init(struct npcm_uart *uart)
{
	//u8 val;

	/* Disable all UART interrupt */
	writeb(0, &uart->ier);

	/* Set port for 8 bit, 1 stop, no parity */
	//val = LCR_WLS_8b;
	writeb(LCR_WLS_8BITS, &uart->lcr);

	/* Reset RX, TX FIFO */
	//val = FCR_FME | FCR_RFR | FCR_TFR | FCR_RFITL_4B;
	writeb(FCR_FME | FCR_RFR | FCR_TFR, &uart->fcr);

	return 0;
}
#endif
static int npcm_serial_pending(struct udevice *dev, bool input)
{
	struct npcm_serial_plat *plat = dev_get_plat(dev);

	if (input)
		return (readb(plat->reg + LSR) & LSR_RFDR);
	else
		return !(readb(plat->reg + LSR) & LSR_THRE);
}

static int npcm_serial_putc(struct udevice *dev, const char ch)
{
	struct npcm_serial_plat *plat = dev_get_plat(dev);

	while (!(readb(plat->reg + LSR) & LSR_THRE))
		;

	writeb(ch, plat->reg + THR);

	return 0;
}

static int npcm_serial_getc(struct udevice *dev)
{
	struct npcm_serial_plat *plat = dev_get_plat(dev);

	while (!(readb(plat->reg + LSR) & LSR_RFDR))
		;

	return (readb(plat->reg + RBR);
}

static int npcm_serial_setbrg(struct udevice *dev, int baudrate)
{
	struct npcm_serial_plat *plat = dev_get_plat(dev);
	u32 divisor;

	/* BaudOut = UART Clock  / (16 * [Divisor + 2]) */
	divisor = DIV_ROUND_CLOSEST(plat->uart_clk, 16 * baudrate + 2) - 2;

	setbits_8(plat->reg + LCR, LCR_DLAB);
	writeb(divisor & 0xff, &uart->dll);
	writeb(divisor >> 8, &uart->dlm);
	clrbits_8(plat->reg + LCR, LCR_DLAB);

	return 0;
}

static int npcm_serial_probe(struct udevice *dev)
{
	struct npcm_serial_plat *plat = dev_get_plat(dev);
	//struct npcm_uart *const uart = plat->reg;
	struct clk clk;
	u32 freq;
	int ret;

	plat->reg = dev_read_addr_ptr(dev);
	freq = dev_read_u32_default(dev, "clock-frequency", 0);

	ret = clk_get_by_index(dev, 0, &clk);
	if (ret < 0) {
		printf("Cannot get clk for uart\n");
		return ret;
	}
	ret = clk_set_rate(&clk, freq);
	if (ret < 0)
		return ret;
	plat->uart_clk = ret;

	/* Disable all interrupt */
	writeb(0, plat->reg + IER);

	/* Set 8 bit, 1 stop, no parity */
	writeb(LCR_WLS_8BITS, plat->reg + LCR);

	/* Reset RX/TX FIFO */
	writeb(FCR_FME | FCR_RFR | FCR_TFR, plat->reg + FCR);

	return 0;
}

static const struct dm_serial_ops npcm_serial_ops = {
	.getc = npcm_serial_getc,
	.setbrg = npcm_serial_setbrg,
	.putc = npcm_serial_putc,
	.pending = npcm_serial_pending,
};

static const struct udevice_id npcm_serial_ids[] = {
	{ .compatible = "nuvoton,npcm750-uart" },
	{ .compatible = "nuvoton,npcm845-uart" },
	{ }
};

U_BOOT_DRIVER(serial_npcm) = {
	.name	= "serial_npcm",
	.id	= UCLASS_SERIAL,
	.of_match = npcm_serial_ids,
	.plat_auto  = sizeof(struct npcm_serial_plat),
	.probe = npcm_serial_probe,
	.ops	= &npcm_serial_ops,
	.flags = DM_FLAG_PRE_RELOC,
};
